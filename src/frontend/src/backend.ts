/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @caffeinelabs/bindgen@0.1.0.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { Actor, HttpAgent, type HttpAgentOptions, type ActorConfig, type Agent, type ActorSubclass } from "@icp-sdk/core/agent";
import type { Principal } from "@icp-sdk/core/principal";
import { idlFactory, type _SERVICE } from "./declarations/backend.did";
export interface Some<T> {
    __kind__: "Some";
    value: T;
}
export interface None {
    __kind__: "None";
}
export type Option<T> = Some<T> | None;
function some<T>(value: T): Some<T> {
    return {
        __kind__: "Some",
        value: value
    };
}
function none(): None {
    return {
        __kind__: "None"
    };
}
function isNone<T>(option: Option<T>): option is None {
    return option.__kind__ === "None";
}
function isSome<T>(option: Option<T>): option is Some<T> {
    return option.__kind__ === "Some";
}
function unwrap<T>(option: Option<T>): T {
    if (isNone(option)) {
        throw new Error("unwrap: none");
    }
    return option.value;
}
function candid_some<T>(value: T): [T] {
    return [
        value
    ];
}
function candid_none<T>(): [] {
    return [];
}
function record_opt_to_undefined<T>(arg: T | null): T | undefined {
    return arg == null ? undefined : arg;
}
export class ExternalBlob {
    _blob?: Uint8Array<ArrayBuffer> | null;
    directURL: string;
    onProgress?: (percentage: number) => void = undefined;
    private constructor(directURL: string, blob: Uint8Array<ArrayBuffer> | null){
        if (blob) {
            this._blob = blob;
        }
        this.directURL = directURL;
    }
    static fromURL(url: string): ExternalBlob {
        return new ExternalBlob(url, null);
    }
    static fromBytes(blob: Uint8Array<ArrayBuffer>): ExternalBlob {
        const url = URL.createObjectURL(new Blob([
            new Uint8Array(blob)
        ], {
            type: 'application/octet-stream'
        }));
        return new ExternalBlob(url, blob);
    }
    public async getBytes(): Promise<Uint8Array<ArrayBuffer>> {
        if (this._blob) {
            return this._blob;
        }
        const response = await fetch(this.directURL);
        const blob = await response.blob();
        this._blob = new Uint8Array(await blob.arrayBuffer());
        return this._blob;
    }
    public getDirectURL(): string {
        return this.directURL;
    }
    public withUploadProgress(onProgress: (percentage: number) => void): ExternalBlob {
        this.onProgress = onProgress;
        return this;
    }
}
export type AttemptId = bigint;
export interface AnalyticsEvent {
    userId?: UserId;
    timestamp: bigint;
    details: string;
    eventType: string;
}
export interface PracticeProgress {
    totalAnswered: bigint;
    totalBookmarked: bigint;
    totalWrong: bigint;
}
export type QuestionId = bigint;
export interface OtpVerifyResult {
    token: string;
    isNew: boolean;
}
export interface Chapter {
    id: ChapterId;
    order: bigint;
    name: string;
    createdAt: bigint;
    course: string;
}
export type ChapterId = bigint;
export type UserId = bigint;
export interface BackupData {
    categories: Array<[bigint, Category]>;
    userAnswers: Array<[Principal, Array<UserAnswer>]>;
    notifications: Array<[bigint, Notification]>;
    nextAttemptId: AttemptId;
    phoneToUserId: Array<[string, UserId]>;
    nextCategoryId: CategoryId;
    nextChapterId: ChapterId;
    chapters: Array<[bigint, Chapter]>;
    questions: Array<[bigint, Question]>;
    userExamResults: Array<[UserId, Array<ExamResult>]>;
    nextNotificationId: NotificationId;
    callerToUserId: Array<[Principal, UserId]>;
    userBookmarks: Array<[Principal, Array<bigint>]>;
    profiles: Array<[Principal, UserProfile]>;
    nextUserId: UserId;
}
export interface UserAnswer {
    id: bigint;
    correct: boolean;
    timestamp: bigint;
    questionId: QuestionId;
    selectedOption: string;
}
export type NotificationId = bigint;
export interface Notification {
    id: NotificationId;
    title: string;
    createdAt: bigint;
    createdBy: Principal;
    message: string;
    targetSegment: string;
}
export interface ExamQuestionReview {
    question: Question;
    userCorrect: boolean;
    correct: boolean;
    originalAnswer?: string;
    selectedOption?: string;
}
export type CategoryId = bigint;
export interface ExamResult {
    questionReviews: Array<ExamQuestionReview>;
    attemptId: AttemptId;
    submitted: boolean;
    userId: UserId;
    answers: Array<UserAnswer>;
    score: bigint;
    timeRemaining: bigint;
    examType: string;
    passed: boolean;
}
export interface Question {
    id: QuestionId;
    question: string;
    hint: string;
    difficulty: Difficulty;
    explanation: string;
    createdAt: bigint;
    answer: string;
    course: string;
    chapter: string;
    optionA: string;
    optionB: string;
    optionC: string;
    optionD: string;
}
export interface UserProfile {
    userId: UserId;
    name: string;
    createdAt: bigint;
    phone: string;
    course: string;
}
export interface Category {
    id: CategoryId;
    name: string;
    createdAt: bigint;
    description: string;
}
export enum Difficulty {
    easy = "easy",
    hard = "hard",
    medium = "medium"
}
export enum UserRole {
    admin = "admin",
    user = "user",
    guest = "guest"
}
export interface backendInterface {
    _initializeAccessControlWithSecret(userSecret: string): Promise<void>;
    addAnalyticsEvent(eventType: string, userId: UserId | null, details: string): Promise<void>;
    addQuestion(course: string, chapter: string, difficulty: Difficulty, questionText: string, optionA: string, optionB: string, optionC: string, optionD: string, answer: string, hint: string, explanation: string): Promise<bigint>;
    assignCallerUserRole(user: Principal, role: UserRole): Promise<void>;
    backupData(): Promise<BackupData>;
    bulkUploadQuestions(questionsData: Array<Question>): Promise<bigint>;
    createCategory(name: string, description: string): Promise<CategoryId>;
    createChapter(course: string, name: string, order: bigint): Promise<bigint>;
    createNotification(title: string, message: string, targetSegment: string): Promise<bigint>;
    deleteCategory(id: CategoryId): Promise<void>;
    deleteChapter(id: bigint): Promise<void>;
    deleteQuestion(id: bigint): Promise<void>;
    exportUserResults(): Promise<Array<[UserId, Array<ExamResult>]>>;
    getAnalyticsEvents(): Promise<Array<AnalyticsEvent>>;
    getAttempts(): Promise<Array<ExamResult>>;
    getBookmarkedQuestions(): Promise<Array<Question>>;
    getCallerUserProfile(): Promise<UserProfile | null>;
    getCallerUserRole(): Promise<UserRole>;
    getExamModeReview(): Promise<{
        examHistory: Array<ExamResult>;
    }>;
    getExamQuestion(attemptId: bigint, questionId: bigint): Promise<ExamQuestionReview>;
    getNotifications(): Promise<Array<Notification>>;
    getPracticeProgress(course: string, chapter: string): Promise<PracticeProgress>;
    getQuestions(course: string | null, chapter: string | null, limit: bigint | null, offset: bigint | null): Promise<Array<Question>>;
    getUserExamHistory(userId: UserId): Promise<Array<ExamResult>>;
    getUserProfile(user: Principal): Promise<UserProfile | null>;
    isCallerAdmin(): Promise<boolean>;
    listCategories(): Promise<Array<Category>>;
    listChapters(course: string | null): Promise<Array<Chapter>>;
    listNotifications(): Promise<Array<Notification>>;
    listUsers(): Promise<Array<[Principal, UserProfile]>>;
    restoreData(backup: BackupData): Promise<void>;
    saveCallerUserProfile(profile: {
        name: string;
        phone: string;
        course: string;
    }): Promise<void>;
    searchQuestions(course: string | null, chapter: string | null, difficulty: Difficulty | null, limit: bigint | null, offset: bigint | null): Promise<Array<Question>>;
    sendOtp(arg0: string): Promise<void>;
    startExam(course: string): Promise<bigint>;
    submitAnswer(questionId: bigint, selectedOption: string): Promise<boolean>;
    submitExam(attemptId: bigint, answers: Array<UserAnswer>): Promise<ExamResult>;
    toggleBookmark(questionId: bigint): Promise<void>;
    updateCategory(id: CategoryId, name: string, description: string): Promise<void>;
    updateChapter(id: bigint, course: string, name: string, order: bigint): Promise<void>;
    updateQuestion(id: bigint, course: string, chapter: string, difficulty: Difficulty, questionText: string, optionA: string, optionB: string, optionC: string, optionD: string, answer: string, hint: string, explanation: string): Promise<void>;
    verifyOtp(phoneNumber: string, arg1: string): Promise<OtpVerifyResult>;
}
import type { AnalyticsEvent as _AnalyticsEvent, AttemptId as _AttemptId, BackupData as _BackupData, Category as _Category, CategoryId as _CategoryId, Chapter as _Chapter, ChapterId as _ChapterId, Difficulty as _Difficulty, ExamQuestionReview as _ExamQuestionReview, ExamResult as _ExamResult, Notification as _Notification, NotificationId as _NotificationId, Question as _Question, QuestionId as _QuestionId, UserAnswer as _UserAnswer, UserId as _UserId, UserProfile as _UserProfile, UserRole as _UserRole } from "./declarations/backend.did.d.ts";
export class Backend implements backendInterface {
    constructor(private actor: ActorSubclass<_SERVICE>, private _uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, private _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, private processError?: (error: unknown) => never){}
    async _initializeAccessControlWithSecret(arg0: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor._initializeAccessControlWithSecret(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor._initializeAccessControlWithSecret(arg0);
            return result;
        }
    }
    async addAnalyticsEvent(arg0: string, arg1: UserId | null, arg2: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.addAnalyticsEvent(arg0, to_candid_opt_n1(this._uploadFile, this._downloadFile, arg1), arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addAnalyticsEvent(arg0, to_candid_opt_n1(this._uploadFile, this._downloadFile, arg1), arg2);
            return result;
        }
    }
    async addQuestion(arg0: string, arg1: string, arg2: Difficulty, arg3: string, arg4: string, arg5: string, arg6: string, arg7: string, arg8: string, arg9: string, arg10: string): Promise<bigint> {
        if (this.processError) {
            try {
                const result = await this.actor.addQuestion(arg0, arg1, to_candid_Difficulty_n2(this._uploadFile, this._downloadFile, arg2), arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.addQuestion(arg0, arg1, to_candid_Difficulty_n2(this._uploadFile, this._downloadFile, arg2), arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
            return result;
        }
    }
    async assignCallerUserRole(arg0: Principal, arg1: UserRole): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.assignCallerUserRole(arg0, to_candid_UserRole_n4(this._uploadFile, this._downloadFile, arg1));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.assignCallerUserRole(arg0, to_candid_UserRole_n4(this._uploadFile, this._downloadFile, arg1));
            return result;
        }
    }
    async backupData(): Promise<BackupData> {
        if (this.processError) {
            try {
                const result = await this.actor.backupData();
                return from_candid_BackupData_n6(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.backupData();
            return from_candid_BackupData_n6(this._uploadFile, this._downloadFile, result);
        }
    }
    async bulkUploadQuestions(arg0: Array<Question>): Promise<bigint> {
        if (this.processError) {
            try {
                const result = await this.actor.bulkUploadQuestions(to_candid_vec_n23(this._uploadFile, this._downloadFile, arg0));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.bulkUploadQuestions(to_candid_vec_n23(this._uploadFile, this._downloadFile, arg0));
            return result;
        }
    }
    async createCategory(arg0: string, arg1: string): Promise<CategoryId> {
        if (this.processError) {
            try {
                const result = await this.actor.createCategory(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createCategory(arg0, arg1);
            return result;
        }
    }
    async createChapter(arg0: string, arg1: string, arg2: bigint): Promise<bigint> {
        if (this.processError) {
            try {
                const result = await this.actor.createChapter(arg0, arg1, arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createChapter(arg0, arg1, arg2);
            return result;
        }
    }
    async createNotification(arg0: string, arg1: string, arg2: string): Promise<bigint> {
        if (this.processError) {
            try {
                const result = await this.actor.createNotification(arg0, arg1, arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createNotification(arg0, arg1, arg2);
            return result;
        }
    }
    async deleteCategory(arg0: CategoryId): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.deleteCategory(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.deleteCategory(arg0);
            return result;
        }
    }
    async deleteChapter(arg0: bigint): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.deleteChapter(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.deleteChapter(arg0);
            return result;
        }
    }
    async deleteQuestion(arg0: bigint): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.deleteQuestion(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.deleteQuestion(arg0);
            return result;
        }
    }
    async exportUserResults(): Promise<Array<[UserId, Array<ExamResult>]>> {
        if (this.processError) {
            try {
                const result = await this.actor.exportUserResults();
                return from_candid_vec_n14(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.exportUserResults();
            return from_candid_vec_n14(this._uploadFile, this._downloadFile, result);
        }
    }
    async getAnalyticsEvents(): Promise<Array<AnalyticsEvent>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAnalyticsEvents();
                return from_candid_vec_n26(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAnalyticsEvents();
            return from_candid_vec_n26(this._uploadFile, this._downloadFile, result);
        }
    }
    async getAttempts(): Promise<Array<ExamResult>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAttempts();
                return from_candid_vec_n16(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAttempts();
            return from_candid_vec_n16(this._uploadFile, this._downloadFile, result);
        }
    }
    async getBookmarkedQuestions(): Promise<Array<Question>> {
        if (this.processError) {
            try {
                const result = await this.actor.getBookmarkedQuestions();
                return from_candid_vec_n30(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getBookmarkedQuestions();
            return from_candid_vec_n30(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCallerUserProfile(): Promise<UserProfile | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getCallerUserProfile();
                return from_candid_opt_n31(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCallerUserProfile();
            return from_candid_opt_n31(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCallerUserRole(): Promise<UserRole> {
        if (this.processError) {
            try {
                const result = await this.actor.getCallerUserRole();
                return from_candid_UserRole_n32(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCallerUserRole();
            return from_candid_UserRole_n32(this._uploadFile, this._downloadFile, result);
        }
    }
    async getExamModeReview(): Promise<{
        examHistory: Array<ExamResult>;
    }> {
        if (this.processError) {
            try {
                const result = await this.actor.getExamModeReview();
                return from_candid_record_n34(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getExamModeReview();
            return from_candid_record_n34(this._uploadFile, this._downloadFile, result);
        }
    }
    async getExamQuestion(arg0: bigint, arg1: bigint): Promise<ExamQuestionReview> {
        if (this.processError) {
            try {
                const result = await this.actor.getExamQuestion(arg0, arg1);
                return from_candid_ExamQuestionReview_n20(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getExamQuestion(arg0, arg1);
            return from_candid_ExamQuestionReview_n20(this._uploadFile, this._downloadFile, result);
        }
    }
    async getNotifications(): Promise<Array<Notification>> {
        if (this.processError) {
            try {
                const result = await this.actor.getNotifications();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getNotifications();
            return result;
        }
    }
    async getPracticeProgress(arg0: string, arg1: string): Promise<PracticeProgress> {
        if (this.processError) {
            try {
                const result = await this.actor.getPracticeProgress(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getPracticeProgress(arg0, arg1);
            return result;
        }
    }
    async getQuestions(arg0: string | null, arg1: string | null, arg2: bigint | null, arg3: bigint | null): Promise<Array<Question>> {
        if (this.processError) {
            try {
                const result = await this.actor.getQuestions(to_candid_opt_n35(this._uploadFile, this._downloadFile, arg0), to_candid_opt_n35(this._uploadFile, this._downloadFile, arg1), to_candid_opt_n36(this._uploadFile, this._downloadFile, arg2), to_candid_opt_n36(this._uploadFile, this._downloadFile, arg3));
                return from_candid_vec_n30(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getQuestions(to_candid_opt_n35(this._uploadFile, this._downloadFile, arg0), to_candid_opt_n35(this._uploadFile, this._downloadFile, arg1), to_candid_opt_n36(this._uploadFile, this._downloadFile, arg2), to_candid_opt_n36(this._uploadFile, this._downloadFile, arg3));
            return from_candid_vec_n30(this._uploadFile, this._downloadFile, result);
        }
    }
    async getUserExamHistory(arg0: UserId): Promise<Array<ExamResult>> {
        if (this.processError) {
            try {
                const result = await this.actor.getUserExamHistory(arg0);
                return from_candid_vec_n16(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getUserExamHistory(arg0);
            return from_candid_vec_n16(this._uploadFile, this._downloadFile, result);
        }
    }
    async getUserProfile(arg0: Principal): Promise<UserProfile | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getUserProfile(arg0);
                return from_candid_opt_n31(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getUserProfile(arg0);
            return from_candid_opt_n31(this._uploadFile, this._downloadFile, result);
        }
    }
    async isCallerAdmin(): Promise<boolean> {
        if (this.processError) {
            try {
                const result = await this.actor.isCallerAdmin();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.isCallerAdmin();
            return result;
        }
    }
    async listCategories(): Promise<Array<Category>> {
        if (this.processError) {
            try {
                const result = await this.actor.listCategories();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.listCategories();
            return result;
        }
    }
    async listChapters(arg0: string | null): Promise<Array<Chapter>> {
        if (this.processError) {
            try {
                const result = await this.actor.listChapters(to_candid_opt_n35(this._uploadFile, this._downloadFile, arg0));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.listChapters(to_candid_opt_n35(this._uploadFile, this._downloadFile, arg0));
            return result;
        }
    }
    async listNotifications(): Promise<Array<Notification>> {
        if (this.processError) {
            try {
                const result = await this.actor.listNotifications();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.listNotifications();
            return result;
        }
    }
    async listUsers(): Promise<Array<[Principal, UserProfile]>> {
        if (this.processError) {
            try {
                const result = await this.actor.listUsers();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.listUsers();
            return result;
        }
    }
    async restoreData(arg0: BackupData): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.restoreData(to_candid_BackupData_n37(this._uploadFile, this._downloadFile, arg0));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.restoreData(to_candid_BackupData_n37(this._uploadFile, this._downloadFile, arg0));
            return result;
        }
    }
    async saveCallerUserProfile(arg0: {
        name: string;
        phone: string;
        course: string;
    }): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.saveCallerUserProfile(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.saveCallerUserProfile(arg0);
            return result;
        }
    }
    async searchQuestions(arg0: string | null, arg1: string | null, arg2: Difficulty | null, arg3: bigint | null, arg4: bigint | null): Promise<Array<Question>> {
        if (this.processError) {
            try {
                const result = await this.actor.searchQuestions(to_candid_opt_n35(this._uploadFile, this._downloadFile, arg0), to_candid_opt_n35(this._uploadFile, this._downloadFile, arg1), to_candid_opt_n49(this._uploadFile, this._downloadFile, arg2), to_candid_opt_n36(this._uploadFile, this._downloadFile, arg3), to_candid_opt_n36(this._uploadFile, this._downloadFile, arg4));
                return from_candid_vec_n30(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.searchQuestions(to_candid_opt_n35(this._uploadFile, this._downloadFile, arg0), to_candid_opt_n35(this._uploadFile, this._downloadFile, arg1), to_candid_opt_n49(this._uploadFile, this._downloadFile, arg2), to_candid_opt_n36(this._uploadFile, this._downloadFile, arg3), to_candid_opt_n36(this._uploadFile, this._downloadFile, arg4));
            return from_candid_vec_n30(this._uploadFile, this._downloadFile, result);
        }
    }
    async sendOtp(arg0: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.sendOtp(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.sendOtp(arg0);
            return result;
        }
    }
    async startExam(arg0: string): Promise<bigint> {
        if (this.processError) {
            try {
                const result = await this.actor.startExam(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.startExam(arg0);
            return result;
        }
    }
    async submitAnswer(arg0: bigint, arg1: string): Promise<boolean> {
        if (this.processError) {
            try {
                const result = await this.actor.submitAnswer(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.submitAnswer(arg0, arg1);
            return result;
        }
    }
    async submitExam(arg0: bigint, arg1: Array<UserAnswer>): Promise<ExamResult> {
        if (this.processError) {
            try {
                const result = await this.actor.submitExam(arg0, arg1);
                return from_candid_ExamResult_n17(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.submitExam(arg0, arg1);
            return from_candid_ExamResult_n17(this._uploadFile, this._downloadFile, result);
        }
    }
    async toggleBookmark(arg0: bigint): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.toggleBookmark(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.toggleBookmark(arg0);
            return result;
        }
    }
    async updateCategory(arg0: CategoryId, arg1: string, arg2: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateCategory(arg0, arg1, arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateCategory(arg0, arg1, arg2);
            return result;
        }
    }
    async updateChapter(arg0: bigint, arg1: string, arg2: string, arg3: bigint): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateChapter(arg0, arg1, arg2, arg3);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateChapter(arg0, arg1, arg2, arg3);
            return result;
        }
    }
    async updateQuestion(arg0: bigint, arg1: string, arg2: string, arg3: Difficulty, arg4: string, arg5: string, arg6: string, arg7: string, arg8: string, arg9: string, arg10: string, arg11: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateQuestion(arg0, arg1, arg2, to_candid_Difficulty_n2(this._uploadFile, this._downloadFile, arg3), arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateQuestion(arg0, arg1, arg2, to_candid_Difficulty_n2(this._uploadFile, this._downloadFile, arg3), arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
            return result;
        }
    }
    async verifyOtp(arg0: string, arg1: string): Promise<OtpVerifyResult> {
        if (this.processError) {
            try {
                const result = await this.actor.verifyOtp(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.verifyOtp(arg0, arg1);
            return result;
        }
    }
}
function from_candid_AnalyticsEvent_n27(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _AnalyticsEvent): AnalyticsEvent {
    return from_candid_record_n28(_uploadFile, _downloadFile, value);
}
function from_candid_BackupData_n6(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _BackupData): BackupData {
    return from_candid_record_n7(_uploadFile, _downloadFile, value);
}
function from_candid_Difficulty_n12(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _Difficulty): Difficulty {
    return from_candid_variant_n13(_uploadFile, _downloadFile, value);
}
function from_candid_ExamQuestionReview_n20(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _ExamQuestionReview): ExamQuestionReview {
    return from_candid_record_n21(_uploadFile, _downloadFile, value);
}
function from_candid_ExamResult_n17(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _ExamResult): ExamResult {
    return from_candid_record_n18(_uploadFile, _downloadFile, value);
}
function from_candid_Question_n10(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _Question): Question {
    return from_candid_record_n11(_uploadFile, _downloadFile, value);
}
function from_candid_UserRole_n32(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _UserRole): UserRole {
    return from_candid_variant_n33(_uploadFile, _downloadFile, value);
}
function from_candid_opt_n22(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [string]): string | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n29(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_UserId]): UserId | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n31(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_UserProfile]): UserProfile | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_record_n11(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    id: _QuestionId;
    question: string;
    hint: string;
    difficulty: _Difficulty;
    explanation: string;
    createdAt: bigint;
    answer: string;
    course: string;
    chapter: string;
    optionA: string;
    optionB: string;
    optionC: string;
    optionD: string;
}): {
    id: QuestionId;
    question: string;
    hint: string;
    difficulty: Difficulty;
    explanation: string;
    createdAt: bigint;
    answer: string;
    course: string;
    chapter: string;
    optionA: string;
    optionB: string;
    optionC: string;
    optionD: string;
} {
    return {
        id: value.id,
        question: value.question,
        hint: value.hint,
        difficulty: from_candid_Difficulty_n12(_uploadFile, _downloadFile, value.difficulty),
        explanation: value.explanation,
        createdAt: value.createdAt,
        answer: value.answer,
        course: value.course,
        chapter: value.chapter,
        optionA: value.optionA,
        optionB: value.optionB,
        optionC: value.optionC,
        optionD: value.optionD
    };
}
function from_candid_record_n18(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    questionReviews: Array<_ExamQuestionReview>;
    attemptId: _AttemptId;
    submitted: boolean;
    userId: _UserId;
    answers: Array<_UserAnswer>;
    score: bigint;
    timeRemaining: bigint;
    examType: string;
    passed: boolean;
}): {
    questionReviews: Array<ExamQuestionReview>;
    attemptId: AttemptId;
    submitted: boolean;
    userId: UserId;
    answers: Array<UserAnswer>;
    score: bigint;
    timeRemaining: bigint;
    examType: string;
    passed: boolean;
} {
    return {
        questionReviews: from_candid_vec_n19(_uploadFile, _downloadFile, value.questionReviews),
        attemptId: value.attemptId,
        submitted: value.submitted,
        userId: value.userId,
        answers: value.answers,
        score: value.score,
        timeRemaining: value.timeRemaining,
        examType: value.examType,
        passed: value.passed
    };
}
function from_candid_record_n21(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    question: _Question;
    userCorrect: boolean;
    correct: boolean;
    originalAnswer: [] | [string];
    selectedOption: [] | [string];
}): {
    question: Question;
    userCorrect: boolean;
    correct: boolean;
    originalAnswer?: string;
    selectedOption?: string;
} {
    return {
        question: from_candid_Question_n10(_uploadFile, _downloadFile, value.question),
        userCorrect: value.userCorrect,
        correct: value.correct,
        originalAnswer: record_opt_to_undefined(from_candid_opt_n22(_uploadFile, _downloadFile, value.originalAnswer)),
        selectedOption: record_opt_to_undefined(from_candid_opt_n22(_uploadFile, _downloadFile, value.selectedOption))
    };
}
function from_candid_record_n28(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    userId: [] | [_UserId];
    timestamp: bigint;
    details: string;
    eventType: string;
}): {
    userId?: UserId;
    timestamp: bigint;
    details: string;
    eventType: string;
} {
    return {
        userId: record_opt_to_undefined(from_candid_opt_n29(_uploadFile, _downloadFile, value.userId)),
        timestamp: value.timestamp,
        details: value.details,
        eventType: value.eventType
    };
}
function from_candid_record_n34(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    examHistory: Array<_ExamResult>;
}): {
    examHistory: Array<ExamResult>;
} {
    return {
        examHistory: from_candid_vec_n16(_uploadFile, _downloadFile, value.examHistory)
    };
}
function from_candid_record_n7(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    categories: Array<[bigint, _Category]>;
    userAnswers: Array<[Principal, Array<_UserAnswer>]>;
    notifications: Array<[bigint, _Notification]>;
    nextAttemptId: _AttemptId;
    phoneToUserId: Array<[string, _UserId]>;
    nextCategoryId: _CategoryId;
    nextChapterId: _ChapterId;
    chapters: Array<[bigint, _Chapter]>;
    questions: Array<[bigint, _Question]>;
    userExamResults: Array<[_UserId, Array<_ExamResult>]>;
    nextNotificationId: _NotificationId;
    callerToUserId: Array<[Principal, _UserId]>;
    userBookmarks: Array<[Principal, Array<bigint>]>;
    profiles: Array<[Principal, _UserProfile]>;
    nextUserId: _UserId;
}): {
    categories: Array<[bigint, Category]>;
    userAnswers: Array<[Principal, Array<UserAnswer>]>;
    notifications: Array<[bigint, Notification]>;
    nextAttemptId: AttemptId;
    phoneToUserId: Array<[string, UserId]>;
    nextCategoryId: CategoryId;
    nextChapterId: ChapterId;
    chapters: Array<[bigint, Chapter]>;
    questions: Array<[bigint, Question]>;
    userExamResults: Array<[UserId, Array<ExamResult>]>;
    nextNotificationId: NotificationId;
    callerToUserId: Array<[Principal, UserId]>;
    userBookmarks: Array<[Principal, Array<bigint>]>;
    profiles: Array<[Principal, UserProfile]>;
    nextUserId: UserId;
} {
    return {
        categories: value.categories,
        userAnswers: value.userAnswers,
        notifications: value.notifications,
        nextAttemptId: value.nextAttemptId,
        phoneToUserId: value.phoneToUserId,
        nextCategoryId: value.nextCategoryId,
        nextChapterId: value.nextChapterId,
        chapters: value.chapters,
        questions: from_candid_vec_n8(_uploadFile, _downloadFile, value.questions),
        userExamResults: from_candid_vec_n14(_uploadFile, _downloadFile, value.userExamResults),
        nextNotificationId: value.nextNotificationId,
        callerToUserId: value.callerToUserId,
        userBookmarks: value.userBookmarks,
        profiles: value.profiles,
        nextUserId: value.nextUserId
    };
}
function from_candid_tuple_n15(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [_UserId, Array<_ExamResult>]): [UserId, Array<ExamResult>] {
    return [
        value[0],
        from_candid_vec_n16(_uploadFile, _downloadFile, value[1])
    ];
}
function from_candid_tuple_n9(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [bigint, _Question]): [bigint, Question] {
    return [
        value[0],
        from_candid_Question_n10(_uploadFile, _downloadFile, value[1])
    ];
}
function from_candid_variant_n13(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    easy: null;
} | {
    hard: null;
} | {
    medium: null;
}): Difficulty {
    return "easy" in value ? Difficulty.easy : "hard" in value ? Difficulty.hard : "medium" in value ? Difficulty.medium : value;
}
function from_candid_variant_n33(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    admin: null;
} | {
    user: null;
} | {
    guest: null;
}): UserRole {
    return "admin" in value ? UserRole.admin : "user" in value ? UserRole.user : "guest" in value ? UserRole.guest : value;
}
function from_candid_vec_n14(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<[_UserId, Array<_ExamResult>]>): Array<[UserId, Array<ExamResult>]> {
    return value.map((x)=>from_candid_tuple_n15(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n16(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_ExamResult>): Array<ExamResult> {
    return value.map((x)=>from_candid_ExamResult_n17(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n19(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_ExamQuestionReview>): Array<ExamQuestionReview> {
    return value.map((x)=>from_candid_ExamQuestionReview_n20(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n26(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_AnalyticsEvent>): Array<AnalyticsEvent> {
    return value.map((x)=>from_candid_AnalyticsEvent_n27(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n30(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_Question>): Array<Question> {
    return value.map((x)=>from_candid_Question_n10(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n8(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<[bigint, _Question]>): Array<[bigint, Question]> {
    return value.map((x)=>from_candid_tuple_n9(_uploadFile, _downloadFile, x));
}
function to_candid_BackupData_n37(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: BackupData): _BackupData {
    return to_candid_record_n38(_uploadFile, _downloadFile, value);
}
function to_candid_Difficulty_n2(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Difficulty): _Difficulty {
    return to_candid_variant_n3(_uploadFile, _downloadFile, value);
}
function to_candid_ExamQuestionReview_n47(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: ExamQuestionReview): _ExamQuestionReview {
    return to_candid_record_n48(_uploadFile, _downloadFile, value);
}
function to_candid_ExamResult_n44(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: ExamResult): _ExamResult {
    return to_candid_record_n45(_uploadFile, _downloadFile, value);
}
function to_candid_Question_n24(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Question): _Question {
    return to_candid_record_n25(_uploadFile, _downloadFile, value);
}
function to_candid_UserRole_n4(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: UserRole): _UserRole {
    return to_candid_variant_n5(_uploadFile, _downloadFile, value);
}
function to_candid_opt_n1(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: UserId | null): [] | [_UserId] {
    return value === null ? candid_none() : candid_some(value);
}
function to_candid_opt_n35(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: string | null): [] | [string] {
    return value === null ? candid_none() : candid_some(value);
}
function to_candid_opt_n36(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: bigint | null): [] | [bigint] {
    return value === null ? candid_none() : candid_some(value);
}
function to_candid_opt_n49(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Difficulty | null): [] | [_Difficulty] {
    return value === null ? candid_none() : candid_some(to_candid_Difficulty_n2(_uploadFile, _downloadFile, value));
}
function to_candid_record_n25(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    id: QuestionId;
    question: string;
    hint: string;
    difficulty: Difficulty;
    explanation: string;
    createdAt: bigint;
    answer: string;
    course: string;
    chapter: string;
    optionA: string;
    optionB: string;
    optionC: string;
    optionD: string;
}): {
    id: _QuestionId;
    question: string;
    hint: string;
    difficulty: _Difficulty;
    explanation: string;
    createdAt: bigint;
    answer: string;
    course: string;
    chapter: string;
    optionA: string;
    optionB: string;
    optionC: string;
    optionD: string;
} {
    return {
        id: value.id,
        question: value.question,
        hint: value.hint,
        difficulty: to_candid_Difficulty_n2(_uploadFile, _downloadFile, value.difficulty),
        explanation: value.explanation,
        createdAt: value.createdAt,
        answer: value.answer,
        course: value.course,
        chapter: value.chapter,
        optionA: value.optionA,
        optionB: value.optionB,
        optionC: value.optionC,
        optionD: value.optionD
    };
}
function to_candid_record_n38(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    categories: Array<[bigint, Category]>;
    userAnswers: Array<[Principal, Array<UserAnswer>]>;
    notifications: Array<[bigint, Notification]>;
    nextAttemptId: AttemptId;
    phoneToUserId: Array<[string, UserId]>;
    nextCategoryId: CategoryId;
    nextChapterId: ChapterId;
    chapters: Array<[bigint, Chapter]>;
    questions: Array<[bigint, Question]>;
    userExamResults: Array<[UserId, Array<ExamResult>]>;
    nextNotificationId: NotificationId;
    callerToUserId: Array<[Principal, UserId]>;
    userBookmarks: Array<[Principal, Array<bigint>]>;
    profiles: Array<[Principal, UserProfile]>;
    nextUserId: UserId;
}): {
    categories: Array<[bigint, _Category]>;
    userAnswers: Array<[Principal, Array<_UserAnswer>]>;
    notifications: Array<[bigint, _Notification]>;
    nextAttemptId: _AttemptId;
    phoneToUserId: Array<[string, _UserId]>;
    nextCategoryId: _CategoryId;
    nextChapterId: _ChapterId;
    chapters: Array<[bigint, _Chapter]>;
    questions: Array<[bigint, _Question]>;
    userExamResults: Array<[_UserId, Array<_ExamResult>]>;
    nextNotificationId: _NotificationId;
    callerToUserId: Array<[Principal, _UserId]>;
    userBookmarks: Array<[Principal, Array<bigint>]>;
    profiles: Array<[Principal, _UserProfile]>;
    nextUserId: _UserId;
} {
    return {
        categories: value.categories,
        userAnswers: value.userAnswers,
        notifications: value.notifications,
        nextAttemptId: value.nextAttemptId,
        phoneToUserId: value.phoneToUserId,
        nextCategoryId: value.nextCategoryId,
        nextChapterId: value.nextChapterId,
        chapters: value.chapters,
        questions: to_candid_vec_n39(_uploadFile, _downloadFile, value.questions),
        userExamResults: to_candid_vec_n41(_uploadFile, _downloadFile, value.userExamResults),
        nextNotificationId: value.nextNotificationId,
        callerToUserId: value.callerToUserId,
        userBookmarks: value.userBookmarks,
        profiles: value.profiles,
        nextUserId: value.nextUserId
    };
}
function to_candid_record_n45(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    questionReviews: Array<ExamQuestionReview>;
    attemptId: AttemptId;
    submitted: boolean;
    userId: UserId;
    answers: Array<UserAnswer>;
    score: bigint;
    timeRemaining: bigint;
    examType: string;
    passed: boolean;
}): {
    questionReviews: Array<_ExamQuestionReview>;
    attemptId: _AttemptId;
    submitted: boolean;
    userId: _UserId;
    answers: Array<_UserAnswer>;
    score: bigint;
    timeRemaining: bigint;
    examType: string;
    passed: boolean;
} {
    return {
        questionReviews: to_candid_vec_n46(_uploadFile, _downloadFile, value.questionReviews),
        attemptId: value.attemptId,
        submitted: value.submitted,
        userId: value.userId,
        answers: value.answers,
        score: value.score,
        timeRemaining: value.timeRemaining,
        examType: value.examType,
        passed: value.passed
    };
}
function to_candid_record_n48(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    question: Question;
    userCorrect: boolean;
    correct: boolean;
    originalAnswer?: string;
    selectedOption?: string;
}): {
    question: _Question;
    userCorrect: boolean;
    correct: boolean;
    originalAnswer: [] | [string];
    selectedOption: [] | [string];
} {
    return {
        question: to_candid_Question_n24(_uploadFile, _downloadFile, value.question),
        userCorrect: value.userCorrect,
        correct: value.correct,
        originalAnswer: value.originalAnswer ? candid_some(value.originalAnswer) : candid_none(),
        selectedOption: value.selectedOption ? candid_some(value.selectedOption) : candid_none()
    };
}
function to_candid_tuple_n40(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [bigint, Question]): [bigint, _Question] {
    return [
        value[0],
        to_candid_Question_n24(_uploadFile, _downloadFile, value[1])
    ];
}
function to_candid_tuple_n42(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [UserId, Array<ExamResult>]): [_UserId, Array<_ExamResult>] {
    return [
        value[0],
        to_candid_vec_n43(_uploadFile, _downloadFile, value[1])
    ];
}
function to_candid_variant_n3(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Difficulty): {
    easy: null;
} | {
    hard: null;
} | {
    medium: null;
} {
    return value == Difficulty.easy ? {
        easy: null
    } : value == Difficulty.hard ? {
        hard: null
    } : value == Difficulty.medium ? {
        medium: null
    } : value;
}
function to_candid_variant_n5(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: UserRole): {
    admin: null;
} | {
    user: null;
} | {
    guest: null;
} {
    return value == UserRole.admin ? {
        admin: null
    } : value == UserRole.user ? {
        user: null
    } : value == UserRole.guest ? {
        guest: null
    } : value;
}
function to_candid_vec_n23(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<Question>): Array<_Question> {
    return value.map((x)=>to_candid_Question_n24(_uploadFile, _downloadFile, x));
}
function to_candid_vec_n39(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<[bigint, Question]>): Array<[bigint, _Question]> {
    return value.map((x)=>to_candid_tuple_n40(_uploadFile, _downloadFile, x));
}
function to_candid_vec_n41(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<[UserId, Array<ExamResult>]>): Array<[_UserId, Array<_ExamResult>]> {
    return value.map((x)=>to_candid_tuple_n42(_uploadFile, _downloadFile, x));
}
function to_candid_vec_n43(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<ExamResult>): Array<_ExamResult> {
    return value.map((x)=>to_candid_ExamResult_n44(_uploadFile, _downloadFile, x));
}
function to_candid_vec_n46(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<ExamQuestionReview>): Array<_ExamQuestionReview> {
    return value.map((x)=>to_candid_ExamQuestionReview_n47(_uploadFile, _downloadFile, x));
}
export interface CreateActorOptions {
    agent?: Agent;
    agentOptions?: HttpAgentOptions;
    actorOptions?: ActorConfig;
    processError?: (error: unknown) => never;
}
export function createActor(canisterId: string, _uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, options: CreateActorOptions = {}): Backend {
    const agent = options.agent || HttpAgent.createSync({
        ...options.agentOptions
    });
    if (options.agent && options.agentOptions) {
        console.warn("Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent.");
    }
    const actor = Actor.createActor<_SERVICE>(idlFactory, {
        agent,
        canisterId: canisterId,
        ...options.actorOptions
    });
    return new Backend(actor, _uploadFile, _downloadFile, options.processError);
}
